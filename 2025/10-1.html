
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>day10.py → HTML/JS</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; line-height: 1.4; }
    textarea { width: 100%; height: 220px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    button { padding: 0.6rem 1rem; margin-right: 0.5rem; }
    .grid { display: grid; gap: 1rem; grid-template-columns: 1fr; max-width: 980px; }
    pre { background: #f6f8fa; padding: 1rem; border-radius: 8px; overflow: auto; }
    .muted { color: #555; }
  </style>
</head>
<body>
  <h1>Convert <code>day10.py</code> logic to HTML/JavaScript</h1>

  <div class="grid">
    <div>
      <p class="muted">Paste the content of <code>in.txt</code> or load the file:</p>
      <input type="file" id="fileInput" accept=".txt" />
      <textarea id="input" placeholder="[##..#] (0,2) (1,3) {1,2,3}
[.#.#.] (0,1) (2,3) (4) {9}"></textarea>
    </div>

    <div>
      <button id="run">Run</button>
      <button id="clear">Clear</button>
    </div>

    <div id="output"></div>
  </div>

  <script>
    // --- Parsing: mirrors your Python split/replace logic ---
    function parseInput(text) {
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const puzzles = [];

      for (const dt of lines) {
        // Extract target lights between [...]
        const lgtMatch = dt.match(/\[([#.]+)\]/);
        const lgt = lgtMatch ? lgtMatch[1].split('') : [];

        // Extract the raw button segment between ] and {, then split by spaces
        const afterBracket = dt.split(']')[1] ?? '';
        const beforeBrace = afterBracket.split('{')[0] ?? '';
        const btnTokens = beforeBrace.trim().split(/\s+/).filter(Boolean);

        // Remove parentheses and split "i,j,..." into integer arrays
        const buttons = btnTokens.map(tok => {
          const cleaned = tok.replace(/[()]/g, '');
          return cleaned.split(',').filter(Boolean).map(s => parseInt(s, 10));
        });

        // Extract numbers inside {...} (kept for parity; not used)
        const nmsMatch = dt.match(/\{([^}]*)\}/);
        const nums = nmsMatch ? nmsMatch[1].split(',').filter(Boolean).map(s => parseInt(s, 10)) : [];

        puzzles.push({ target: lgt, buttons, nums });
      }
      return puzzles;
    }

    // Toggle helper: identical effect to appbt(btn, l, gm) in Python
    function applyButton(btn, lights) {
      const nl = lights.slice();
      for (const i of btn) {
        if (!Number.isInteger(i)) continue;
        if (i < 0 || i >= nl.length) continue; // ignore out-of-range safely
        nl[i] = (nl[i] === '#') ? '.' : '#';
      }
      return nl;
    }

    // Equality for arrays (mirrors Python list equality in `if bt not in bl`)
    function arraysEqual(a, b) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
      return true;
    }

    // BFS: mirrors findp(i) — never press the same button twice
    function minimalPresses(puzzle) {
      const target = puzzle.target;
      const n = target.length;
      const targetKey = target.join('');
      const start = Array(n).fill('.');
      const startKey = start.join('');

      const queue = [{ seq: [], lights: start }];
      const seen = new Set([startKey]);

      while (queue.length) {
        const { seq, lights } = queue.shift();
        const key = lights.join('');
        if (key === targetKey) {
          return { count: seq.length, seq };
        }

        for (const btn of puzzle.buttons) {
          // don't reuse same button in sequence (structural equality)
          if (seq.some(s => arraysEqual(s, btn))) continue;

          const next = applyButton(btn, lights);
          const nextKey = next.join('');
          if (!seen.has(nextKey)) {
            seen.add(nextKey);
            queue.push({ seq: [...seq, btn], lights: next });
          }
        }
      }

      // If unreachable (should be rare), return null to signal "no solution"
      return { count: null, seq: [] };
    }

    function runAll() {
      const puzzles = parseInput(document.getElementById('input').value);
      if (puzzles.length === 0) {
        document.getElementById('output').innerHTML = '<p>No valid lines found.</p>';
        return;
      }

      let total = 0;
      const linesOut = [];

      puzzles.forEach((p, idx) => {
        const res = minimalPresses(p);
        if (res.count == null) {
          linesOut.push(`Line ${idx + 1}: no solution found`);
        } else {
          total += res.count;
          linesOut.push(`Line ${idx + 1}: minimal presses = ${res.count}`);
        }
      });

      document.getElementById('output').innerHTML =
        `<p><strong>Total minimal presses across all lines: ${total}</strong></p>` +
        `<pre>${linesOut.join('\n')}</pre>`;
    }

    // UI wiring
    document.getElementById('run').addEventListener('click', runAll);
    document.getElementById('clear').addEventListener('click', () => {
      document.getElementById('input').value = '';
      document.getElementById('output').innerHTML = '';
    });

    // Optional: load file content into textarea
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const text = await file.text();
      document.getElementById('input').value = text;
    });
  </script>
</body>
</html>
